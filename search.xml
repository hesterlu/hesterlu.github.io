<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F11%2FC%2B%2B%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[title: c++笔记date: 2018-10-30tags: 基本语法 题目：c++笔记1 类 一、定义抽象数据类型 类的基本思想是数据抽象和封装，首先要定义一个抽象数据类型 定义在类体内部的是默认内联函数 成员函数可以定义在类体内部也可以定义在类体外部 this指针的地址就是对象的首地址，this形参是隐式定义的，任何自定义名为this的参数和变量都是非法的，this是常量指针，不能改变this中保存的地址 数据成员和成员函数都是类的成员 允许把const关键字放在成员函数的参数列表之后，这样使用const的成员函数成为常量成员函数 常量对象、常量对象的引用和指针都只能调用常量成员函数 成员函数可以任意使用类体内的成员 成员函数在类外声明 成员函数在类外定义必须包含所属的类名double Sales_data::avg_price() const {}//定义在类体作用域内 combine类似于赋值运算符+=，调用combine的是运算符左侧的对象，右侧对象由实参显式的传入 12345678Sales_data&amp; Sales_data::combine(const Sales_data &amp;rhs)&#123; units_sold+=rhs.units_+sold; revenue+=rhs.revenue; return *this;//解引用获得调用combine函数的指针&#125;//total的地址绑定在隐式的this参数上，rhs绑定到trans//combine返回类型必须是引用 ··· 非成员函数在概念上属于类，但不定义在类中，函数声明与类在同一个头文件中 源文件通#include关联头文件 二、访问控制和封装 我们使用访问控制符加强类的封装性public说明符：成员在整个程序可以被访问，定义类的接口private说明符：成员可以被类内成员函数访问，private封装了类的实现细节 class或者struct（1）访问权限不一样class：类在访问类型符之前定义成员，这些成员的访问权限是privatestruct：类在访问类型符之前定义的成员访问权限是public 封装可以确保用户代码不会破坏封装对象的状态 友元（1）read、print和add是接口函数，Sales_data的数据成员是private，此时接口函数无法访问，程序无法正常编译，类允许友元函数访问他的私有成员（2）增加friend关键字开始声明友元函数，友元函数的声明只能出现在类的内部1234class Sales_data &#123;friend istream &amp;read(istream &amp;is, Sales_data &amp;item);friend ostream &amp;print(ostream &amp;os, const Sales_data &amp;item);friend Sales_data add(const Sales_data &amp;lhs, const Sales_data &amp;rhs); （3）友元函数的声明仅仅指定了访问的权限（4）将友元函数的声明和类放置在一个头文件中（类外部）（5）类可以把其他类定义成友元（friend class window_mgr;）（6）也可以把其他类的成员函数定义成友元（friend void window_mgr::clear();）成员函数作为友元时，需要满足程序结构的声明和定义彼此依赖的关系（7）友元没有传递性，window_mgr的友元不能访问screen（8）如果要把一组重载函数全都声明成友元，需要逐个全部声明（9）在类内部声明的友元函数只是对友元函数访问权限有作用，在类外部使用友元函数之前，友元函数必须已经被声明 三、类的其他特性 类的成员、类的成员的类内初始值、可变数据成员、内联成员函数、从成员函数返回*this screen类123456789101112131415class screen&#123; public: typedef string::size_type ps;// screen()=default;//合成默认构造函数 screen(pos ht,pos wd,char c):height(ht),width(wd),contents(ht*wd,c)&#123;&#125; char get() const &#123;return contents[cursor];&#125; inline char get(pos ht,pos wd) const; screen &amp;move(pos r,pos c); private: pos cursor=0; pos height=0,width=0; string contents;&#125;; 3.内联函数一些规模较小的函数适合于被声明成内联函数，定义在类体内的所有函数都是内联函数,无须在声明和定义的地方同时定义内联 1234567891011inline screen &amp;screen::move(pos r,pos c)&#123; pos row=r*width; cursor=row+c; return *this;&#125;char screen::get(pos r,pos c)const&#123; pos row=r*width; return contents[row+c];&#125; 4.重载成员函数和非成员函数类似5.可变数据成员在变量声明中加上mutable，可变数据成员永远不会是const，一个const成员函数可以改变一个可变成员给screen添加一个可变数据成员access_ctr,可以通过它追踪每个screen的成员函数被调用的次数6.类数据成员的初始值窗口管理类window_mgr，包含一个screen类型的vector，每个元素有一个screen将screen默认声明成类内初始值12345class window_mgr&#123;private： vector&lt;screen&gt;screens&#123;screen(24,80,&apos; &apos;)&#125;//screen的值被传递给vector&lt;screen&gt;的构造函数，创建了一个单元素的vector对象（一个固定大小的空白屏幕）&#125;; 7.返回*this的成员函数（1）123456789101112131415class screen&#123;public: screen &amp;set(char);//返回类型是引用 screen &amp;set(pos,pos ,char);&#125;;inline screen &amp;screen::set(char c)&#123; contents[cursor]=c;//设置光标当前位置新值 return *this;//解引用this对象，作为左值返回&#125;inline screen &amp;screen::set(pos r,pos col,char c)&#123; contents[r*width+col]=ch;//设置给定位置的新值 return *this;&#125; （2）从const成员函数返回this*？（3）基于const的重载只能在一个常量对象上调用const成员函数，可以在非常量对象上调用常量版本和非常量版本 类类型（1）即使两个类的成员列表完全一致，它们也是不同的类型（2）前项声明：在类定义之前先声明类 （class screen；）此时，screen是一个不完全类型（3）在创建一个类的对象之前，类必须已经被定义 四、类的作用域 在类的作用域之外，成员只能通过对象、指针和引用使用成员访问运算符来访问 类类型成员使用作用域运算符访问 类的定义分两步处理：（1）编译成员的声明（2）编译器处理完类中的全部声明后，才会处理成员函数的定义，所以成员函数可以使用类中定义的任何名字 用类成员声明的名字查找 如果外层作用域中，某个名字代表一种类型，则在类中不能再定义该名字 可以通过作用域运算符调用全局变量 五、构造函数1.构造函数（1）构造函数的任务是初始化类对象的数据成员，只要类的对象被创建，就会执行构造函数（2）构造函数的名字和类名相同，但是没有返回类型，有参数列表和函数体（可能为空）（3）类可以包含多个构造函数，参数数量和参数类型需要有所不同（4）构造函数不能被定义为const类型，创建一个const类型的对象时，知道构造函数初始化完成时，对象才能获得const属性，构造函数可以在const对象构造过程中直接向其写值（5）合成的默认构造函数如果存在类内初始值，用来初始化成员否则，默认初始化该成员（6）对于一个普通的类，必须定义默认初始化只有编译器发现类不含有任何构造函数时才会生成默认构造函数合成的默认构造函数可能执行错误操作（如定义在块中的内置类型或者是符合类型，默认初始化会造成未定义行为）有时候编译器不能为某些类合成默认构造函数12345678910//为Sales_data新增四个不同的构造函数struct Sales_data&#123;Sales_data()=default;//不接受任何实参，是一个默认构造函数，=default要求系统生成默认构造函数Sales_data(const string &amp;s):bookNo(s)&#123;&#125;//bookNo(s)构造函数初始值列表，给新创建的对象的一个或多个对象赋初值，s是初始值Sales_data(const string &amp;s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n)&#123;&#125;//units_sold和revenue都没有显示的初始化，通过其他值获得Sales_data(istream&amp;);//空参数列表，定义的默认构造函数...&#125;; （7）在类体外定义构造函数123456Sales_data::Sales_data(istream &amp;is)//这个构造函数没有初始值列表，通过相应的类内初始值进行初始化，或者进行类内初始化//&#123; read(is,*this);// *this将this对象作为实参传递给read函数&#125; 2.拷贝、赋值和析构（1）初始化变量、值传递或返回一个对象（2）编译器会对对象进行拷贝、拷贝 和销毁的操作（3）某些类在合成的版本下无法工作，例如管理动态内存的类不能依赖于上述操作的合成版本（4）但是很多使用动态内存的类应该使用vector或者string对象管必要的存储空间3.如果成员是const或者引用，则必须将其初始化，可以通过构造函数初始值列表进行初始化4.成员初始化：成员初始化顺序和在类中出现的顺序一致，构造函数初始值列表只说明用于初始化成员的值，不限定顺序，应该尽量避免用一个成员初始化另一个成员5.委托构造函数使用所属类的其他构造函数执行他的初始化过程，参数列表必须与类中的另一个参数列表匹配6.隐式的类类型转换 （1）只允许一步类类型转换-page264 （2）类类型转换不总是有效的 （3）抑制构造函数定义的隐式转换，在构造函数声明语句的最前面加上explicit，explicit只对一个实参的构造函数有效，只能用于直接初始化 （4）用了explicit的构造函数仍然能够进行显示的初始化7.聚合类可以使用户直接访问其成员 （1）所有成员都是public （2）没有定义任何构造函数 （3）没有类内初始值 （4）没有基类也没有virtual函数（第十五章见） （5）可以用一个花括号括起来的成员初始值列表，用他初始化聚合类的数据成员，初始值的顺序必须和声明的顺序一致 （6）如果初始值列表的元素少于类的成员数量，则靠后的成员被值初始化7.字面值常量类（1）字面值类可能含有constexper（2）数据类型都是字面值的聚合类是字面值常量类（3）满足以下条件的也是字面值常量类：数据成员必须是字面值类型；类至少含有一个constexper构造函数；含有类内初始值的数据成员，内置类型的成员初始值必须是一条常量表达式；如果成员属于某种类型，初始值必须使用自己的constexper构造函数类必须使用析构函数的内置定义（4）构造函数不能是const，但是字面值常量的构造函数可以是constexper（5）constexper构造函数可以被声明成=default的形式或者是删除函数的形式（6）constexper构造函数体一般为空（7）constexper构造函数必须初始化所有数据成员，初始值使用constexper或者常量表达式 六、类的静态成员 声明静态成员：类的静态成员存在于类的对象之外，对象中不包含与静态数据成员有关的数据 静态成员函数，不包含this指针，不能被声明成const 使用作用域运算符直接访问静态成员：double r;r=Account::rate(); 虽然静态成员不属于某个对象，但是对象仍然可以访问静态成员，静态成员不是由构造函数进行初始化的 成员函数访问静态成员不需要作用域运算符 定义类的静态成员可以在类内，也可以在类外；在类外部定义静态成员时，不能重复static关键字，static关键字只出现在类内部的声明语句 静态数据成员定义在函数之外，类似于全局变量，一旦被定义就存在在程序的整个生命周期 为确保静态数据成员只定义一次，可以和其他非内联函数的定义放在同一个文件夹中12345678 class Account&#123;public: static double rate()&#123;return interestRate;&#125; static void rate(double);private: static constexpr int period=30;//此时，period的唯一用途是作为daily_tbl的维度，不需要在类外定义 double daily_tbl[period];&#125;; ··· 静态数据成员可以是不完全类型，静态数据成员的类型可以是他所所属的类的类型10.非静态成员不能作为默认实参，因为非静态成员的值是对象的一部分，静态成员可以]]></content>
  </entry>
</search>
